# springcloudproject
wuhu~~~~~
# JVM

## GC的基础知识

### 1.什么是垃圾

​	c语言中申请内存：malloc | free

​	c++: new | delete

​	java: new | ?（自动内存回收，编程简单，系统不容易出错）

​	容易出两种类型的问题：

​	1.忘记回收  (容易引起内存泄漏)

​	2.多次回收 

没有任何引用指向的一个或多个对象（循环引用)-垃圾

### 2.定位垃圾

​	1.引用计数器(不能解决循环引用问题)

​	2.根可达算法

​	GC roots：

​		GC Roots对象包括：

​			1.虚拟机栈（栈帧中的本地变量表）中引用的对象；

​			2.方法区中的类静态属性引用的对象；

​			3.方法区中常量引用的对象；

​			4.本地方法栈中JNI（即一般说的Native方法）中引用的对象；

​			

![image-20200802091149120](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200802091149120.png)

### 3.常见的垃圾回收算法

##### 	1.标记清除：找到垃圾进行标记-清除

###### 		将垃圾回收分为两个阶段： 标记阶段和清除阶段，在标记阶段，首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后再清除阶段，清除所有未被标记的对象，

###### 标记清除算法缺点：存在大量的空间碎片，因为回收的空间是不连续的，这样给大对象分配内存空间的时候，可能回提前触发fullGC。



​		![image-20200802091401359](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200802091401359.png)

###### 	问题：位置不连续，产生碎片

##### 	2.拷贝算法：没有碎片，连续的，但是浪费空间

###### 	将现有的内存空间分为两块，每次只是使用其中的一块，再垃圾回收时，将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

![image-20200802091559086](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200802091559086.png)

##### 	3.标记-整理：没有碎片，连续，效率比拷贝算法低

复制算法的高效性是建立再存活对象少，垃圾对象多的前提下，这种情况再新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象，如果依然使用复制算法，由于存活对象较多，复制成本也很高。

标记-整理算法是一种老年代的回收算法，它在标记-清除的算法上进行优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单的清除未被标记的对象，而是将所有存活的对象压缩到内存的一端，之后，清理边界外所有的空间，这中方法可以避免随便的产生，但是又不需要两块相同的内存空间，性价比较高。

##### 4.分代收集算法：

根据对象的存活周期的不同，将内存划分为几块。一般把java堆分为新生代和老年代，这样可以根据各个年代的特点采用适当的收集算法。

新生代：每次垃圾收集时发现有大量的对象死去，只有少量存活，那就选用复制算法。只需要付出少量存活对象的复制成本，就可以完成收集。

老年代：对象存活率高，没有额外空间对它进行分配，就必须要使用标记-清理或者标记-整理算法来进行回收。

![image-20200802091758234](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200802091758234.png)

### JVM分代算法(jdk8)

​	1.部分垃圾回收器使用的模型

​	2.新生代+老年代+永久带(1.7)/元数据区(1.8)Metaspace

​		1.永久代和元数据：Class

​		2.永久代必须指定大小限制；元数据区大小无上限，可以设置也可以不设置(受限于物理内存)

​		3.字符串常量：1.7存在永久代 ；1.8存在堆

​		4.MethodArea逻辑概念-永久代，元数据

​	3.运行时堆内存逻辑分区

​		1.新生代=eden+两个survior区  

​			1.YGC回收之后，大多数的对象会被回收；(拷贝算法) 将活着对象copy到s0区，将eden区进行			清除

​			2.再次YGC,活着对象 eden+s0->s1

​			3.再次 YGC,活着对象 eden+s1->s0

​			4.年龄足够->老年代

​			5.s区装不下->老年代

​		2.老年代

​			1.顽固分子

​			2.老年代满了触发FULL GC  （新生代+老年代整个堆内存的回收，造成卡顿，效率低）

​	4.GC Tuning(调优目标)

​		1.尽量减少FGC

​			![image-20200802094505008](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200802094505008.png)

​	5.常见垃圾回收器

​	![image-20200802095040186](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200802095040186.png)

##### 	1.Serial收集器：

年轻代-单线程-(应用程序运行时，内存不足，触发YGC，停下当前所有应用程序，垃圾回收处理，处理完成执行程序)YGC执行时，应用程序停顿

对单个cpu运行环境来说，serial收集器由于没有线程交互的开销，专心做垃圾回收，自然可以获取到最高的单线程收集效率。

![image-20200828112757944](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200828112757944.png)

##### 	2.ParNew收集器：

ParNew收集器时serial收集器新生代的多线程实现，垃圾回收的时候依然回STW，只是相比较serial收集器而言它会运行使用多线程进行进行垃圾回收，因此在并发能力上比较强的cpu上，他产生的卡顿时间要短于串行回收期。

![image-20200828112830239](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200828112830239.png)

##### 3.CMS收集器：(并发标记，低停顿)

CMS收集器时一种以获取最短回收停顿时间为目标的收集器。基于‘标记-清除’算法实现。

初始标记——》并发标记——》重新标记——》并发清除

###### 初始标记、重新标记着两个步骤仍然会有STW，初始标记仅仅只是标记一下GC ROOTS能直接关联的对象，并发标记阶段就是继续GC ROOTS Tracing,而重新标记阶段是为了修正并发标记期间因用户线程继续运作而导致标记产生表动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段长点，但是远比并发标记时间短。

![image-20200828141152413](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200828141152413.png)

2.ps年轻代并行回收

​	3.parnew年轻代配合CMS的并行回收

​	4.seriaOld

​	5.psOld

​	6.ConcurrentMarkSweep:老年代 （效率高）并发的垃圾回收和应用程序同时运行，降低STW的

​	时间(200ms)

​	7.G1（10ms）

​	8.ZGC（1ms）

​	9.Shenandoah

​	10.Epllson

​	1.8默认的垃圾回收器：ps+paralleOld

## 6.JVM调优

​	jvm命令行参数参考：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java/html

​	jvm命令参数分类：

​		标准参数：-开头，所有的HotSpot都支持

​		非标准参数：-x开头，特定版本HotSpot支持待定命令

​		不稳定参数：-xx开头，下个版本可能取消

![image-20200802102001368](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200802102001368.png)



java -XX:+PrintCommandLineFlags(查看当前启动命令行参数)

![image-20200802102730636](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200802102730636.png)

java -XX:+PrintFlagsFinal （最终参数值）



————————————————————————————————————————————————————————————————————————————————

熟悉GC常用算法，熟悉常见垃圾收集器，具有实际JVM调优经验★

GC:定位垃圾，进行回收；

分代模型垃圾回收算法：

1.新生代：包含一个eden区+2个survivor区

​	回收过程：创建对象时分配到eden区，对象大部分都是朝生熄灭的，一次回收大部分垃圾

​	对象，只有少了对象存活。采用拷贝算法(将存活对象copy到s0区，然后将eden区剩余垃圾对象，	全部回收)效率高

2.老年代：tenured,再新生代反复copy的对象或者新生代放不下的对象会放到老年代

![image-20200802110053918](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200802110053918.png)



![image-20200802110723474](C:\Users\yubingqian\AppData\Roaming\Typora\typora-user-images\image-20200802110723474.png)

##### ＪＶＭ内存模型及分区：

jvm分为堆区和栈区，还有方法区，初始化的对象放在堆里，引用放在栈里，class类信息常量池(static常量和static变量)等放在方法区

##### 1、栈(Stack-线程私有)

##### 栈：

的结构是栈帧组成的，调用一个方法就是压入一帧，帧上面存储（局部变量表，操作数栈，方法出口等信息）每一个方法从调用直到执行完成的过程，就对应一个栈帧在虚拟机中入栈到出栈的过程。局部变量表存放的是8大基础类型加上一个引用类型，所以还是一个指向地址的指针。

##### 栈帧：

是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值、异常分派。栈帧随着方法的调用而创建，随着方法的结束而销毁—无论方法是正常完成还是异常完成，都算方法结束。

jvm为每一个线程创建一个栈，用于存储改线程执行方法的信息(实际参数、局部变量)

栈特性：后进先出，由系统自动分配速度快且栈是一个连续的存储空间。

##### 2、堆——运行时数据区(线程共享)

##### 堆：

堆是被线程共享的一块内存区域，创建的对象和数组都保存在java堆中，也是垃圾收集器进行垃圾回收的最重要的区域。由于现代vm采用分代收集算法，因此java堆从GC角度还可以分为:新生代（eden区、from survivor区和to survivor区）和老年代。

jvm只有一个堆，被所有线程所共享。

堆是一个不连续的存储空间，分配灵活但是速度慢。

![img](https://img2018.cnblogs.com/blog/1158841/201906/1158841-20190603215303583-831284687.png)

##### 3、方法区、永久代(线程共享)

主要是存储类信息，常量池(static常量和static变量)，编译后的代码（字节码）等数据（永远不变或唯一的内容）。







------------------------------------------------------------------------



##### java类加载过程

1.加载

加载是类加载的第一个过程，在这个阶段，将完成三件事情：a.通过一个类的全限定名获取该类的二进制流

b.将该二进制流中的静态存储结构转化为方法去运行时数据结构。c.在内存中生成该类的class对象，作为该类的数据访问入口。

2.验证

验证的目的是为了确保class文件的字节流中的信息不会危害到虚拟机，在该阶段主要完成4中验证：

a.文件格式验证：验证字节流是否符合class文件规范，如主次版本号是否在当前虚拟机返回内，常量池中的常量是否有不被支持的类型。

b.元数据验证：对字节码描述的信息进行语义分析，如果这个类是否有父类，是否集成了不被集成的类等。

c.字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如果：方法中的类型转换是否正确，跳转指令是否正确等。

d.符号引用验证：这个动作在后面的解析过程中发生，主要是尾了确保解析动作能够正确执行。

3.准备

准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在java堆中。

4.解析

该阶段主要完成符合引用到直接引用的转换动作。解析动作并不一定在初始化完成之前，也有可能在初始化之后。

5.初始化

初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制，到了初始化阶段，才真正开始执行类中的定义的java程序代码。

6.使用

7.卸载

2.java内存分配

寄存器：我们无法控制。

静态域：static定义静态成员。

常量池：编译时被确定保证在.class文件中的final常量值和一些文本修饰的符号引用。(类和接口的全限定名，字段的名称和描述符，方法和名称和描述符)

堆内存：new创建的对象和数组，有java虚拟机自动垃圾回收器管理，存取速度慢。

栈内存：基本类型的变量和对象的引用变量(堆内存空间的访问地址)，速度快，可以共享，但是大小与生命周期必须确定，缺乏灵活性。

3.java堆的结构：

jvm的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在jvm启动的时候被创建。对象所占的堆内存是自动内存管理系统也就是垃圾回收期回收。

堆内存是由存活和死亡的对象组成，存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问的尚且还没有被垃圾回收器回收调的对象。一直到垃圾回收器把这些对象回收掉之前，它会一直占据堆内存空间。

4.jvm加载class文件的原理机制？

java语言是一种具有动态性的解释型语言，类只有被加载到jvm后才能运行。当运行指定程序时，jvm会将编译生成的.class文件按照需求和一定的规则加载到内存中，并组织成为一个完成的java应用程序。这个加载过程是由类加载器完成的，具体来说，就是由classloader和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。

类的加载方式分为隐式加载和显式加载，隐式加载指的是程序在使用new等方式创建对象时，会隐式的调用类的加载器把对应的类加载到jvm中。显式加载指的是通过直接调用class.forname()方法把所需要的类加载到jvm中。

任何一个工程项目都是由许多类组成的，当程序启动时，只把需要的类加载到jvm中，其他路类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行时对内存的开销。此外，在java语言中，每个类或接口都对应一个.class文件，这些文件可以被看成是一个个可以动态加载的单元。因此当只有部分类被修改时，只需要重新编译变化的类即可。而不是需要重新编译所有的文件，因此加快了编译速度。

在java语言中，类加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基类完全加载到jvm中，至于其他类，则在需要的时候才会加载。



5.简述垃圾回收机制

在java中，程序员是不需要显式的去释放一个对象的内存的，而是由虚拟机自行执行。在jvm中有一个垃圾回收线程，他是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

6.如何判断一个对象是否存活？

a.引用计数器法：

给每一个对象设置一个引用计数器，每当有一个地方引用这个对象的时候，就将计数器加1，引用失效时，计数器减1.当一个对象的引用计数器为0时，说明对象没有被引用，也就是‘死对象’，将会被垃圾回收器进行回收。

引用计数器法无法解决对象循环依赖问题。

b.可达性算法

从一个GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明对象不可用。在java中可以作为GC Roots的对象有：

*虚拟机栈中的引用对象

*方法区类静态属性引用的对象

*方法区常量池引用的对象

*本地方法栈JNI引用的对象

虽然这些算法可以判定一个对象是否能够被回收，但是当满足上述条件时，一个对象不一定会被回收。当一个对象不可达GC Roots时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记.









































